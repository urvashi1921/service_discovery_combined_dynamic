

# ========================================
# PREREQUISITE: Detect Available Tools
# ========================================
- name: Detect network tool
  shell: |
    if command -v ss >/dev/null 2>&1; then echo "ss"
    elif command -v netstat >/dev/null 2>&1; then echo "netstat"
    elif command -v lsof >/dev/null 2>&1; then echo "lsof"
    else echo "none"; fi
  register: network_tool
  changed_when: false
  failed_when: false


# ========================================
# SINGLE PS COMMAND - EXTRACT EVERYTHING
# (Uses printf instead of heredoc to avoid YAML parsing issues)
# ========================================


- name: Extract all MySQL/MariaDB process details in one call
  shell: |
    ps aux | awk '$11 ~ /(mysqld|mariadbd)$/ && $11 !~ /grep/' | while read -r line; do
      pid=$(echo "$line" | awk '{print $2}')
      binary=$(echo "$line" | awk '{print $11}')

      # Strict validation: binary must end with mysqld or mariadbd
      if [[ ! "$binary" =~ (mysqld|mariadbd)$ ]]; then
        continue
      fi

      # Verify the process is still running
      if ! kill -0 "$pid" 2>/dev/null; then
        continue
      fi

      # Verify binary exists and is executable (or at least present)
      if [ ! -x "$binary" ] && [ ! -e "$binary" ]; then
        continue
      fi

      # Double check via /proc/pid/cmdline
      if [ -f "/proc/$pid/cmdline" ]; then
        cmdline=$(tr '\0' ' ' < "/proc/$pid/cmdline")
        if [[ ! "$cmdline" =~ (mysqld|mariadbd) ]]; then
          continue
        fi
      else
        continue
      fi

      full_args=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf "%s ", $i; print ""}')
      basedir=$(echo "$full_args" | sed -n 's/.*--basedir=\([^ ]*\).*/\1/p' | head -1)
      datadir=$(echo "$full_args" | sed -n 's/.*--datadir=\([^ ]*\).*/\1/p' | head -1)
      defaults_file=$(echo "$full_args" | sed -n 's/.*--defaults-file=\([^ ]*\).*/\1/p' | head -1)
      socket=$(echo "$full_args" | sed -n 's/.*--socket=\([^ ]*\).*/\1/p' | head -1)
      port=$(echo "$full_args" | sed -n 's/.*--port=\([^ ]*\).*/\1/p' | head -1)

      # X Plugin args (both styles) and mysqlx enable flag
      mysqlx_port=$(echo "$full_args" | sed -n 's/.*--mysqlx-port=\([^ ]*\).*/\1/p; s/.*--mysqlx_port=\([^ ]*\).*/\1/p' | head -1)
      mysqlx_flag=$(echo "$full_args" | sed -n 's/.*--mysqlx=\([^ ]*\).*/\1/p' | head -1)

      # Canonicalize binary path
      if [ -n "$binary" ] && [ -e "$binary" ]; then
        binary=$(readlink -f "$binary" 2>/dev/null || echo "$binary")
      fi

      # Derive instance key preference
      if [ -n "$datadir" ] && [ -d "$datadir" ]; then
        instance_key="$datadir"
      elif [ -n "$basedir" ] && [ -d "$basedir" ]; then
        instance_key="$basedir"
      elif [ -n "$defaults_file" ] && [ -f "$defaults_file" ]; then
        instance_key="$defaults_file"
      else
        instance_key="$binary"
      fi

      printf '{"pid":"%s","binary":"%s","basedir":"%s","datadir":"%s","defaults_file":"%s","socket":"%s","port":"%s","mysqlx_port":"%s","mysqlx_flag":"%s","instance_key":"%s"}\n' \
        "$pid" "${binary:-not-found}" "${basedir:-}" "${datadir:-}" "${defaults_file:-}" "${socket:-}" "${port:-}" "${mysqlx_port:-}" "${mysqlx_flag:-}" "$instance_key"
    done
  args:
    executable: /bin/bash
  register: mysql_processes_raw
  changed_when: false
  failed_when: false

 
 
 

- debug:
    var: mysql_processes_raw.stdout_lines

# ========================================
# PARSE RAW OUTPUT INTO STRUCTURED DATA
# ========================================
- name: Parse MySQL processes into list
  set_fact:
    mysql_processes: "{{ mysql_processes_raw.stdout_lines | default([]) | map('from_json') | list }}"
  when: mysql_processes_raw.stdout_lines | default([]) | length > 0

- name: Set empty list if no processes found
  set_fact:
    mysql_processes: []
  when: mysql_processes_raw.stdout_lines | default([]) | length == 0

# ========================================
# GROUP BY UNIQUE INSTANCE KEY
# ========================================
- name: Get unique instance keys
  set_fact:
    mysql_unique_instances: "{{ mysql_processes | map(attribute='instance_key') | unique | list }}"
  when: mysql_processes | length > 0

- name: Set empty instances if no processes
  set_fact:
    mysql_unique_instances: []
  when: mysql_processes | length == 0

# ========================================
# CREATE DATA COLLECTION SCRIPT
# ========================================
- name: Create MySQL data collection script
  copy:
    dest: /tmp/mysql_collect_data.sh
    mode: '0755'
    content: |
      #!/bin/bash
      INSTANCE_KEY="$1"
      NETWORK_TOOL="$2"
      BINARY="$3"
      PIDS_INPUT="$4"
      BASEDIR="$5"
      DATADIR="$6"
      DEFAULTS_FILE="$7"
      SOCKET_INPUT="$8"
      PORT_INPUT="$9"
      MYSQLX_PORT_INPUT="${10}"
      MYSQLX_FLAG_INPUT="${11}"

      # Ensure mysqld/mariadbd
      if [[ ! "$BINARY" =~ (mysqld|mariadbd)$ ]]; then
        exit 0
      fi
      [ ! -e "$BINARY" ] && exit 0

      # Filter valid PIDs
      PIDS=""
      for pid in $(echo "$PIDS_INPUT" | tr ',' ' '); do
        if kill -0 "$pid" 2>/dev/null && [ -f "/proc/$pid/cmdline" ]; then
          cmdline=$(tr '\0' ' ' < "/proc/$pid/cmdline")
          [[ "$cmdline" =~ (mysqld|mariadbd) ]] && PIDS="$PIDS,$pid"
        fi
      done
      PIDS="${PIDS#,}"
      [ -z "$PIDS" ] && exit 0

      # Version
      VERSION="unknown"
      if [ -x "$BINARY" ]; then
        VERSION=$("$BINARY" --version 2>/dev/null | head -n1 \
          | sed -n 's/.*Ver \([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p' | head -1)
      fi
      [ -z "$VERSION" ] && VERSION="unknown"

      # Config resolution (zero-scan near binary/datadir)
      CONFIG_FILE=""
      if [ -n "$DEFAULTS_FILE" ] && [ -f "$DEFAULTS_FILE" ]; then
        CONFIG_FILE=$(readlink -f "$DEFAULTS_FILE" 2>/dev/null || echo "$DEFAULTS_FILE")
      fi
      if [ -z "$CONFIG_FILE" ] && [ -n "$BINARY" ]; then
        BIN_DIR=$(dirname "$BINARY")
        for conf in "$BIN_DIR/my.cnf" "$BIN_DIR/../my.cnf" "$BIN_DIR/../etc/my.cnf"; do
          if [ -f "$conf" ]; then CONFIG_FILE=$(readlink -f "$conf" 2>/dev/null || echo "$conf"); break; fi
        done
      fi
      if [ -z "$CONFIG_FILE" ] && [ -n "$DATADIR" ]; then
        DATA_PARENT=$(dirname "$DATADIR")
        for conf in "$DATA_PARENT/my.cnf" "$DATA_PARENT/etc/my.cnf"; do
          if [ -f "$conf" ]; then CONFIG_FILE=$(readlink -f "$conf" 2>/dev/null || echo "$conf"); break; fi
        done
      fi
      [ -z "$CONFIG_FILE" ] && CONFIG_FILE="not-found"

      # Socket (no forced default)
      SOCKET="$SOCKET_INPUT"
      if [ -z "$SOCKET" ]; then
        for sock in "$DATADIR/mysql.sock" "$DATADIR/mysqld.sock" /var/run/mysqld/mysqld.sock /tmp/mysql.sock; do
          if [ -S "$sock" ]; then SOCKET="$sock"; break; fi
        done
      fi
      [ -z "$SOCKET" ] && SOCKET="not-found"

      # Network candidates (actual listeners of the mysqld PIDs)
      PORTS_RAW=""
      case "$NETWORK_TOOL" in
        ss)
          for pid in $(echo "$PIDS" | tr ',' ' '); do
            PORTS_RAW="$PORTS_RAW $(ss -ltnp 2>/dev/null | grep -w "pid=$pid" | awk '{print $4}' | awk -F: '{print $NF}')"
          done
          ;;
        netstat)
          for pid in $(echo "$PIDS" | tr ',' ' '); do
            PORTS_RAW="$PORTS_RAW $(netstat -tulnp 2>/dev/null | awk -v p="$pid/" '$0 ~ p {print $4}' | awk -F: '{print $NF}')"
          done
          ;;
        lsof)
          for pid in $(echo "$PIDS" | tr ',' ' '); do
            PORTS_RAW="$PORTS_RAW $(lsof -p "$pid" -i -P -n 2>/dev/null | awk 'NR>1 {print $9}' | awk -F: '{print $2}')"
          done
          ;;
      esac
      PORTS_LIST=$(echo "$PORTS_RAW" | tr ' ' '\n' | grep -E '^[0-9]+$' | sort -u)

      # Extract classic port + mysqlx_port + mysqlx flag from config (if available)
      CFG_PORT=""
      CFG_MYSQLX_PORT=""
      CFG_MYSQLX_FLAG=""
      if [ -f "$CONFIG_FILE" ]; then
        CFG_PORT=$(awk '
          BEGIN{IGNORECASE=1; sec=""}
          /^\s*\[.*\]\s*$/ { s=$0; gsub(/[\[\]]/,"",s); sec=s }
          /^[[:space:]]*port[[:space:]]*=/ {
            if (sec=="mysqld" || sec=="server") {
              gsub(/[[:space:]]/, "", $0);
              split($0,a,"=");
              if (a[2] ~ /^[0-9]+$/) { print a[2]; exit }
            }
          }' "$CONFIG_FILE" | head -n1)

        CFG_MYSQLX_PORT=$(awk '
          BEGIN{IGNORECASE=1}
          /^[[:space:]]*mysqlx[_-]?port[[:space:]]*=/ {
            gsub(/[[:space:]]/, "", $0);
            split($0,a,"=");
            if (a[2] ~ /^[0-9]+$/) { print a[2]; exit }
          }' "$CONFIG_FILE" | head -n1)

        CFG_MYSQLX_FLAG=$(awk '
          BEGIN{IGNORECASE=1}
          /^[[:space:]]*mysqlx[[:space:]]*=/ {
            gsub(/[[:space:]]/, "", $0);
            split($0,a,"=");
            print a[2]; exit
          }' "$CONFIG_FILE" | head -n1)
      fi

      # Normalize flags like ON/OFF/1/0 â†’ ON/OFF
      norm_flag() {
        v=$(echo "$1" | tr '[:lower:]' '[:upper:]')
        case "$v" in
          1|ON|TRUE|YES) echo "ON" ;;
          0|OFF|FALSE|NO) echo "OFF" ;;
          *) echo "" ;;
        esac
      }
      MYSQLX_FLAG_NORM="$(norm_flag "$MYSQLX_FLAG_INPUT")"
      CFG_MYSQLX_FLAG_NORM="$(norm_flag "$CFG_MYSQLX_FLAG")"

      # Build exclusion set for X Plugin port(s)
      EXCLUDE_PORTS=""
      if echo "$MYSQLX_PORT_INPUT" | grep -qE '^[0-9]+$'; then
        EXCLUDE_PORTS="$EXCLUDE_PORTS $MYSQLX_PORT_INPUT"
      fi
      if echo "$CFG_MYSQLX_PORT" | grep -qE '^[0-9]+$'; then
        EXCLUDE_PORTS="$EXCLUDE_PORTS $CFG_MYSQLX_PORT"
      fi
      # If mysqlx is enabled but no port specified anywhere, exclude default 33060
      if [ -z "$MYSQLX_PORT_INPUT$CFG_MYSQLX_PORT" ]; then
        if [ "$MYSQLX_FLAG_NORM" = "ON" ] || [ "$CFG_MYSQLX_FLAG_NORM" = "ON" ]; then
          EXCLUDE_PORTS="$EXCLUDE_PORTS 33060"
        fi
      fi

      # Count how many listener ports were seen
      PORTS_COUNT=$(echo "$PORTS_LIST" | sed '/^$/d' | wc -l | awk '{print $1}')

      # Final port selection (no hardcoded classic default)
      # Priority:
      #   1) CFG_PORT from config
      #   2) PORT_INPUT from process args
      #   3) From actual listeners (exclude X Plugin); if multiple remain and one is 33060, drop 33060; then pick smallest
      FINAL_PORT=""
      if echo "$CFG_PORT" | grep -qE '^[0-9]+$'; then
        FINAL_PORT="$CFG_PORT"
      elif echo "$PORT_INPUT" | grep -qE '^[0-9]+$'; then
        FINAL_PORT="$PORT_INPUT"
      else
        FILTERED=""
        for p in $PORTS_LIST; do
          skip=""
          # drop explicitly excluded X Plugin ports
          for x in $EXCLUDE_PORTS; do
            [ "$p" = "$x" ] && skip="yes" && break
          done
          # pragmatic rule: if multiple listeners and one is 33060, drop 33060
          if [ "$PORTS_COUNT" -gt 1 ] && [ "$p" = "33060" ]; then
            skip="yes"
          fi
          [ -z "$skip" ] && FILTERED="$FILTERED $p"
        done
        FINAL_PORT=$(echo "$FILTERED" | tr ' ' '\n' | grep -E '^[0-9]+$' | sort -n | head -n1)
      fi

      if [ -z "$FINAL_PORT" ]; then
        PORTS="none"
      else
        PORTS="$FINAL_PORT"
      fi

      echo "VERSION=$VERSION|||PORTS=$PORTS|||SOCKET=$SOCKET|||CONFIG=$CONFIG_FILE|||PIDS=$PIDS"
  when: mysql_unique_instances | length > 0

# ========================================
# BUILD INSTANCE DATA FROM PARSED PROCESSES
# ========================================
- name: Collect additional data for each instance
  shell: |
    /tmp/mysql_collect_data.sh \
      "{{ item }}" \
      "{{ network_tool.stdout }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='binary') | first) | default('not-found') }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='pid') | join(',')) }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='basedir') | select() | first) | default('') }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='datadir') | select() | first) | default('') }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='defaults_file') | select() | first) | default('') }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='socket') | select() | first) | default('') }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='port') | select() | first) | default('') }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='mysqlx_port') | select() | first) | default('') }}" \
      "{{ (mysql_processes | selectattr('instance_key', 'equalto', item) | map(attribute='mysqlx_flag') | select() | first) | default('') }}"
  register: mysql_additional_data
  changed_when: false
  failed_when: false
  loop: "{{ mysql_unique_instances }}"
  when: mysql_unique_instances | length > 0

# ========================================
# CLEANUP SCRIPT
# ========================================
- name: Remove temp script
  file:
    path: /tmp/mysql_collect_data.sh
    state: absent
  when: mysql_unique_instances | length > 0


# ========================================
# BUILD FINAL JSON STRUCTURE
# ========================================
- name: Initialize discovery array
  set_fact:
    discovery_array: []

- name: Parse each MySQL instance
  set_fact:
    discovery_array: "{{ discovery_array + [json_instance] }}"
  vars:
    instance_key: "{{ item.item }}"
    additional_data: "{{ item.stdout | default('') }}"
    instance_processes: "{{ mysql_processes | selectattr('instance_key', 'equalto', instance_key) | list }}"

    # Extract values from script output
    version: "{{ (additional_data | regex_search('VERSION=([^|]+)', '\\1') | default(['unknown'], true)) | first }}"
    ports_raw: "{{ (additional_data | regex_search('PORTS=([^|]+)', '\\1') | default([''], true)) | first }}"
    socket_path: "{{ (additional_data | regex_search('SOCKET=([^|]+)', '\\1') | default([''], true)) | first }}"
    config_path: "{{ (additional_data | regex_search('CONFIG=([^|]+)', '\\1') | default(['not-found'], true)) | first }}"
    pids_raw: "{{ (additional_data | regex_search('PIDS=([^|]+)', '\\1') | default([''], true)) | first }}"

    # Convert to arrays
    pids_array: "{{ pids_raw.split(',') | select() | map('int') | list if pids_raw | length > 0 else [] }}"
    ports_array: "{{ ports_raw.split(',') | select() | map('int') | list if ports_raw | length > 0 and ports_raw != 'none' else [] }}"

    binary_path: "{{ (instance_processes | map(attribute='binary') | select() | first) | default('not-found') }}"
    datadir: "{{ (instance_processes | map(attribute='datadir') | select() | first) | default(instance_key) }}"
    name: "{{ datadir | basename }}"

    json_instance:
      service_type: "DATABASE"
      service_name: "mysql"
      service_version: "{{ version }}"
      port: "{{ ports_array[0] if ports_array | length > 0 else 0 }}"
      pid: "{{ pids_array[0] if pids_array | length > 0 else 0 }}"

      paths:
        binary_path: "{{ binary_path }}"
        config_path: "{{ config_path }}"
        data_path: "{{ datadir }}"
        socket_path: "{{ socket_path }}"

      additional_details:
        all_ports: "{{ ports_array }}"
        all_pids: "{{ pids_array }}"

      status: "{{ 'RUNNING' if pids_array | length > 0 else 'STOPPED' }}"
  loop: "{{ mysql_additional_data.results | default([]) }}"
  when:
        - mysql_unique_instances is defined
        - mysql_unique_instances | length > 0
        - item.stdout is defined
        - item.stdout | length > 0
        - "'PIDS=' in item.stdout"
        - (item.stdout | regex_search('PIDS=([^|]+)', '\\1') | default([''], true) | first | length) > 0
  
    
- name: Append MySQL services to discovered_services
  set_fact:
    discovered_services: "{{ (discovered_services | default([])) + (discovery_array | default([])) }}"
